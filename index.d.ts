/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Image format enum */
export const enum ImageFormat {
  Jpeg = 'Jpeg',
  Png = 'Png',
  WebP = 'WebP',
  Gif = 'Gif',
  Bmp = 'Bmp',
  Ico = 'Ico',
  Tiff = 'Tiff'
}
/** Resize filter/algorithm */
export const enum ResizeFilter {
  /** Nearest neighbor - fastest, lowest quality */
  Nearest = 'Nearest',
  /** Bilinear - fast, good quality */
  Bilinear = 'Bilinear',
  /** Catmull-Rom - balanced speed and quality */
  CatmullRom = 'CatmullRom',
  /** Mitchell - good for downscaling */
  Mitchell = 'Mitchell',
  /** Lanczos3 - highest quality, slower */
  Lanczos3 = 'Lanczos3'
}
/** Image fit mode for resize */
export const enum FitMode {
  /** Resize to cover the target dimensions (may crop) */
  Cover = 'Cover',
  /** Resize to fit within target dimensions (may have padding) */
  Contain = 'Contain',
  /** Resize to exact dimensions (may distort) */
  Fill = 'Fill',
  /** Resize only if larger than target */
  Inside = 'Inside',
  /** Resize only if smaller than target */
  Outside = 'Outside'
}
/** Resize options */
export interface ResizeOptions {
  /** Target width (optional if height is provided) */
  width?: number
  /** Target height (optional if width is provided) */
  height?: number
  /** Resize filter/algorithm (default: Lanczos3) */
  filter?: ResizeFilter
  /** Fit mode (default: Cover) */
  fit?: FitMode
  /** Background color for padding [r, g, b, a] (default: transparent) */
  background?: Array<number>
}
/** JPEG encode options */
export interface JpegOptions {
  /** Quality 1-100 (default: 80) */
  quality?: number
}
/** PNG encode options */
export interface PngOptions {
  /** Compression level 0-9 (default: 6) */
  compression?: number
}
/** WebP encode options */
export interface WebPOptions {
  /** Quality 1-100 for lossy, ignored for lossless (default: 80) */
  quality?: number
  /** Use lossless compression (default: false) */
  lossless?: boolean
}
/** Output format options */
export interface OutputOptions {
  /** Output format */
  format: ImageFormat
  /** JPEG options (if format is JPEG) */
  jpeg?: JpegOptions
  /** PNG options (if format is PNG) */
  png?: PngOptions
  /** WebP options (if format is WebP) */
  webp?: WebPOptions
}
/** Image metadata (similar to sharp's output) */
export interface ImageMetadata {
  /** Image width in pixels */
  width: number
  /** Image height in pixels */
  height: number
  /** Detected format (jpeg, png, webp, gif, bmp, ico, tiff) */
  format: string
  /** File size in bytes (if available) */
  size?: number
  /** Color space (srgb, rgb, grayscale) */
  space: string
  /** Number of channels (1, 2, 3, or 4) */
  channels: number
  /** Bit depth per sample (uchar = 8-bit) */
  depth: string
  /** Whether the image has an alpha channel */
  hasAlpha: boolean
  /** Bits per sample */
  bitsPerSample: number
  /** Whether the image is progressive (JPEG) or interlaced (PNG) */
  isProgressive: boolean
  /** Whether the image uses palette/indexed colors (PNG/GIF) */
  isPalette: boolean
  /** Whether the image has an embedded ICC profile */
  hasProfile: boolean
  /** EXIF orientation value (1-8, if present) */
  orientation?: number
  /** Page/frame count for multi-page images (GIF, TIFF) */
  pages?: number
  /** Loop count for animated images */
  loopCount?: number
  /** Delay between frames in ms (for animated images) */
  delay?: Array<number>
  /** Background color (for GIF) */
  background?: Array<number>
  /** Compression type used */
  compression?: string
  /** Density/DPI info */
  density?: number
}
/** Raw hash result for blurhash */
export interface BlurHashResult {
  /** The blurhash string */
  hash: string
  /** Original width */
  width: number
  /** Original height */
  height: number
}
/** Transform options (all-in-one processing) */
export interface TransformOptions {
  /** Resize options */
  resize?: ResizeOptions
  /** Output options */
  output?: OutputOptions
  /** Rotate degrees (90, 180, 270) */
  rotate?: number
  /** Flip horizontally */
  flipH?: boolean
  /** Flip vertically */
  flipV?: boolean
  /** Grayscale conversion */
  grayscale?: boolean
  /** Blur radius (0-100) - use integer, will be converted to float internally */
  blur?: number
  /** Sharpen amount (0-100) - use integer, will be converted to float internally */
  sharpen?: number
  /** Brightness adjustment (-100 to 100) */
  brightness?: number
  /** Contrast adjustment (-100 to 100) */
  contrast?: number
}
/** Get image metadata synchronously */
export declare function metadataSync(input: Buffer): ImageMetadata
/** Resize image synchronously - uses scale-on-decode for JPEG optimization */
export declare function resizeSync(input: Buffer, options: ResizeOptions): Buffer
/** Convert image to JPEG synchronously */
export declare function toJpegSync(input: Buffer, options?: JpegOptions | undefined | null): Buffer
/** Convert image to PNG synchronously */
export declare function toPngSync(input: Buffer, options?: PngOptions | undefined | null): Buffer
/** Convert image to WebP synchronously */
export declare function toWebpSync(input: Buffer, options?: WebPOptions | undefined | null): Buffer
/** Transform image with multiple operations synchronously */
export declare function transformSync(input: Buffer, options: TransformOptions): Buffer
/** Generate blurhash from image synchronously */
export declare function blurhashSync(input: Buffer, componentsX?: number | undefined | null, componentsY?: number | undefined | null): BlurHashResult
/** Get image metadata asynchronously */
export declare function metadata(input: Buffer): Promise<ImageMetadata>
/** Resize image asynchronously - uses scale-on-decode for JPEG optimization */
export declare function resize(input: Buffer, options: ResizeOptions): Promise<Buffer>
/** Convert image to JPEG asynchronously */
export declare function toJpeg(input: Buffer, options?: JpegOptions | undefined | null): Promise<Buffer>
/** Convert image to PNG asynchronously */
export declare function toPng(input: Buffer, options?: PngOptions | undefined | null): Promise<Buffer>
/** Convert image to WebP asynchronously */
export declare function toWebp(input: Buffer, options?: WebPOptions | undefined | null): Promise<Buffer>
/** Transform image with multiple operations asynchronously */
export declare function transform(input: Buffer, options: TransformOptions): Promise<Buffer>
/** Generate blurhash from image asynchronously */
export declare function blurhash(input: Buffer, componentsX?: number | undefined | null, componentsY?: number | undefined | null): Promise<BlurHashResult>
/** Get library version */
export declare function version(): string
